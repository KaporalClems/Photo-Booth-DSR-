<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth La Réunion</title>

    <!-- Font Awesome pour les icônes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

    <!-- Styles CSS intégrés -->
    <style>
        /* Styles généraux pour le corps de la page */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Prend au moins toute la hauteur de la fenêtre */
            margin: 0; /* Supprime les marges par défaut du corps */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Police de caractères moderne */
            color: #333; /* Couleur de texte foncée */
            
            /* Applique l'image en fond d'écran */
            background-image: url('Cadre photo png.jpg'); /* Chemin vers ton image */
            background-size: cover; /* Couvre toute la zone, peut recadrer l'image */
            background-position: center center; /* Centre l'image */
            background-repeat: no-repeat; /* Ne répète pas l'image */
            background-attachment: fixed; /* Fixe l'image en arrière-plan lors du défilement */
            
            position: relative; /* Essentiel pour le positionnement absolu des enfants (webcam, canvas, boutons) */
            overflow: hidden; /* Empêche les barres de défilement si les éléments dépassent */
        }

        /* Élément vidéo de la webcam */
        #webcam-feed {
            position: absolute; /* Positionné absolument par rapport au body */
            object-fit: cover; /* Assure que la vidéo remplit l'espace sans déformation */
            transform: scaleX(-1); /* Effet miroir pour que l'utilisateur se voie comme dans un miroir */
            border-radius: 8px; /* Coins arrondis */
            z-index: 1; /* Assure qu'il est en dessous du canvas et des boutons */
            /* La taille et la position (top, left, width, height) seront définies par JavaScript */
        }

        /* Élément canvas pour dessiner la photo et le cadre */
        #photo-canvas {
            position: absolute; /* Positionné absolument par rapport au body */
            border-radius: 8px; /* Coins arrondis */
            z-index: 2; /* Au-dessus de la vidéo, en dessous des boutons */
            /* La taille et la position (top, left, width, height) seront définies par JavaScript */
        }

        /* Styles de base pour tous les boutons d'icônes */
        .icon-button {
            position: absolute; /* Positionné absolument par rapport au body */
            background-color: rgba(0, 0, 0, 0.5); /* Fond semi-transparent */
            color: white;
            border: none;
            border-radius: 50%; /* Boutons ronds */
            width: 50px; /* Taille des boutons */
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em; /* Taille de l'icône */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10; /* Au-dessus de tout */
        }

        .icon-button:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.05);
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button:disabled {
            background-color: rgba(150, 150, 150, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        /* Positionnement du bouton de prise de photo (icône caméra) */
        #take-photo-btn {
            /* Ces valeurs sont des estimations basées sur le cadre, à ajuster si nécessaire */
            bottom: 10vh; /* Positionné plus haut pour être sur le cadre */
            left: 50%;
            transform: translateX(-50%);
            background-color: #28a745; /* Vert */
        }
        #take-photo-btn:hover {
            background-color: #218838;
        }

        /* Positionnement du bouton de changement de caméra (icône flip) */
        #flip-camera-btn {
            /* Ces valeurs sont des estimations basées sur le cadre, à ajuster si nécessaire */
            top: 5vh; /* Positionné en haut du cadre */
            left: 50%;
            transform: translateX(-50%);
            background-color: #007bff; /* Bleu */
        }
        #flip-camera-btn:hover {
            background-color: #0056b3;
        }

        /* Positionnement du bouton de téléchargement (texte "TÉLÉCHARGER") */
        #download-btn {
            position: absolute; /* Positionné absolument par rapport au body */
            /* Ces valeurs sont des estimations basées sur le cadre, à ajuster si nécessaire */
            bottom: 5vh; /* 5% de la hauteur de la fenêtre du bas */
            right: 5vw; /* 5% de la largeur de la fenêtre de la droite */
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            background-color: #ffc107; /* Jaune */
            color: #333; /* Texte foncé pour le contraste */
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Au-dessus de tout */
        }
        #download-btn:hover:not(:disabled) {
            background-color: #e0a800;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        #download-btn:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #download-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Ajustements responsifs pour les petits écrans (smartphones) */
        @media (max-width: 600px) {
            .icon-button {
                width: 45px;
                height: 45px;
                font-size: 1.3em;
            }

            #take-photo-btn {
                bottom: 8vh; /* Ajuste la position des boutons */
            }
            #flip-camera-btn {
                top: 4vh;
            }
            #download-btn {
                bottom: 4vh;
                right: 4vw;
                padding: 8px 15px;
                font-size: 0.9em;
            }
        }
    </style>

    <!-- Manifest de l'application pour PWA (Progressive Web App) -->
    <!-- Ce fichier doit être créé séparément dans le même dossier -->
    <link rel="manifest" href="manifest.json">
</head>
<body>
    <!-- Webcam feed et canvas sont maintenant des enfants directs du body -->
    <video id="webcam-feed" autoplay playsinline></video>
    <canvas id="photo-canvas"></canvas>
    <!-- L'image du cadre est toujours chargée mais cachée. Elle est utilisée par le JS pour le dessin sur le canvas. -->
    <img id="frame-overlay" src="Cadre photo png.png" alt="Cadre Photo" style="display: none;">

    <!-- Boutons sont aussi des enfants directs du body -->
    <!-- Bouton pour prendre la photo (icône caméra) -->
    <button id="take-photo-btn" class="icon-button">
        <i class="fas fa-camera"></i>
    </button>

    <!-- Bouton pour changer de caméra (icône flip) -->
    <button id="flip-camera-btn" class="icon-button">
        <i class="fas fa-sync-alt"></i>
    </button>

    <!-- Bouton pour télécharger la photo (texte "TÉLÉCHARGER") -->
    <button id="download-btn" disabled>TÉLÉCHARGER</button>

    <!-- Logique JavaScript intégrée -->
    <script>
        // Récupération des éléments du DOM
        const webcamFeed = document.getElementById('webcam-feed');
        const photoCanvas = document.getElementById('photo-canvas');
        const context = photoCanvas.getContext('2d'); // Contexte de dessin 2D du canvas
        const takePhotoBtn = document.getElementById('take-photo-btn');
        const flipCameraBtn = document.getElementById('flip-camera-btn'); // Nouveau bouton flip
        const downloadBtn = document.getElementById('download-btn');
        const frameOverlay = document.getElementById('frame-overlay'); // L'élément <img> du cadre

        let stream; // Variable pour stocker le flux vidéo de la webcam
        let photoDataUrl; // Variable pour stocker l'URL de la photo prise (format base64)
        let currentCameraId = null; // ID de la caméra actuellement utilisée
        let videoInputDevices = []; // Liste des caméras disponibles

        // Fonction pour énumérer les caméras disponibles
        async function enumerateCameras() {
            videoInputDevices = [];
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                devices.forEach(device => {
                    if (device.kind === 'videoinput') {
                        videoInputDevices.push(device);
                    }
                });
                // Active/désactive le bouton flip si plus d'une caméra est disponible
                flipCameraBtn.disabled = videoInputDevices.length <= 1;
            } catch (error) {
                console.error("Erreur lors de l'énumération des caméras :", error);
                flipCameraBtn.disabled = true; // Désactive le bouton en cas d'erreur
            }
        }

        // Fonction asynchrone pour démarrer la webcam
        async function startWebcam(deviceId = null) {
            // Arrête le flux précédent si existant
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    facingMode: 'user' // Par défaut, caméra frontale
                }
            };

            if (deviceId) {
                // Si un deviceId est spécifié, l'utilise
                constraints.video = { deviceId: { exact: deviceId } };
            } else if (videoInputDevices.length > 0) {
                // Si pas de deviceId, mais des caméras sont énumérées, utilise la première
                // ou essaie de trouver la caméra frontale par défaut
                const frontCamera = videoInputDevices.find(device => device.label.toLowerCase().includes('front'));
                if (frontCamera) {
                    constraints.video = { deviceId: { exact: frontCamera.deviceId } };
                    currentCameraId = frontCamera.deviceId;
                } else {
                    constraints.video = { deviceId: { exact: videoInputDevices[0].deviceId } };
                    currentCameraId = videoInputDevices[0].deviceId;
                }
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                webcamFeed.srcObject = stream; // Associe le flux à l'élément vidéo
                webcamFeed.onloadedmetadata = () => {
                    // Les dimensions du canvas seront définies par setWebcamAndCanvasPosition
                    // pour correspondre à la zone du cadre.
                    console.log(`Webcam feed native dimensions: ${webcamFeed.videoWidth}x${webcamFeed.videoHeight}`);
                };
            } catch (error) {
                console.error("Erreur d'accès à la webcam :", error);
                alert("Impossible d'accéder à votre webcam. Veuillez vérifier les permissions de votre navigateur et assurez-vous que le site est servi via HTTPS.");
                // Si l'accès échoue, désactive les boutons liés à la caméra
                takePhotoBtn.disabled = true;
                flipCameraBtn.disabled = true;
            }
        }

        // Fonction pour calculer et définir la position et la taille de la webcam et du canvas
        function setWebcamAndCanvasPosition() {
            const imgW = 720; // Largeur originale de Cadre photo png.jpg
            const imgH = 960; // Hauteur originale de Cadre photo png.jpg
            // Coordonnées de la zone transparente du cadre dans l'image originale (en pixels)
            const originalCutoutX = 100; 
            const originalCutoutY = 280; 
            const originalCutoutWidth = 520; 
            const originalCutoutHeight = 400;

            const vw = window.innerWidth;
            const vh = window.innerHeight;

            const aspectRatioBody = vw / vh;
            const aspectRatioImg = imgW / imgH;

            let renderedImgW, renderedImgH;

            // Calcule la taille réelle de l'image de fond après application de background-size: cover
            if (aspectRatioBody > aspectRatioImg) {
                // Le viewport est plus large que l'image, l'image remplit la hauteur du viewport
                renderedImgH = vh;
                renderedImgW = vh * aspectRatioImg;
            } else {
                // Le viewport est plus haut ou a le même aspect ratio que l'image, l'image remplit la largeur du viewport
                renderedImgW = vw;
                renderedImgH = vw / aspectRatioImg;
            }

            // Calcule les décalages pour centrer l'image de fond
            const offsetX = (vw - renderedImgW) / 2; // Décalage gauche
            const offsetY = (vh - renderedImgH) / 2; // Décalage haut

            // Calcule le facteur d'échelle de l'image de fond
            const scaleFactor = renderedImgW / imgW; 

            // Calcule les dimensions finales et la position de la zone de découpe sur l'écran
            const finalCutoutX = offsetX + originalCutoutX * scaleFactor;
            const finalCutoutY = offsetY + originalCutoutY * scaleFactor;
            const finalCutoutWidth = originalCutoutWidth * scaleFactor;
            const finalCutoutHeight = originalCutoutHeight * scaleFactor;

            // Applique les styles calculés à la webcam et au canvas
            webcamFeed.style.left = `${finalCutoutX}px`;
            webcamFeed.style.top = `${finalCutoutY}px`;
            webcamFeed.style.width = `${finalCutoutWidth}px`;
            webcamFeed.style.height = `${finalCutoutHeight}px`;

            photoCanvas.style.left = `${finalCutoutX}px`;
            photoCanvas.style.top = `${finalCutoutY}px`;
            photoCanvas.style.width = `${finalCutoutWidth}px`;
            photoCanvas.style.height = `${finalCutoutHeight}px`;

            // Met à jour les dimensions du canvas pour le dessin
            photoCanvas.width = finalCutoutWidth;
            photoCanvas.height = finalCutoutHeight;

            console.log(`Webcam/Canvas positioned at: ${finalCutoutX}x${finalCutoutY} with size ${finalCutoutWidth}x${finalCutoutHeight}`);
        }

        // Écouteur d'événement pour le bouton "Prendre Photo"
        takePhotoBtn.addEventListener('click', () => {
            if (!stream) {
                alert("La webcam n'est pas démarrée. Veuillez patienter ou recharger la page.");
                return;
            }

            // 1. Nettoie le canvas avant de dessiner
            context.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
            
            // 2. Dessine le flux vidéo de la webcam sur le canvas (qui est déjà dimensionné à la zone de découpe)
            const videoAspectRatio = webcamFeed.videoWidth / webcamFeed.videoHeight;
            const canvasAspectRatio = photoCanvas.width / photoCanvas.height;

            let drawVideoWidth, drawVideoHeight, drawVideoX, drawVideoY;

            if (videoAspectRatio > canvasAspectRatio) {
                // La vidéo est plus large que la zone du canvas, on ajuste la hauteur et on centre la largeur
                drawVideoHeight = photoCanvas.height;
                drawVideoWidth = photoCanvas.height * videoAspectRatio;
                drawVideoX = (photoCanvas.width - drawVideoWidth) / 2;
                drawVideoY = 0;
            } else {
                // La vidéo est plus haute que la zone du canvas, on ajuste la largeur et on centre la hauteur
                drawVideoWidth = photoCanvas.width;
                drawVideoHeight = photoCanvas.width / videoAspectRatio;
                drawVideoX = 0;
                drawVideoY = (photoCanvas.height - drawVideoHeight) / 2;
            }

            // Dessine le flux webcam SANS l'effet miroir pour la photo finale
            // L'effet miroir est géré uniquement par le CSS de #webcam-feed pour la prévisualisation en direct.
            context.drawImage(webcamFeed, drawVideoX, drawVideoY, drawVideoWidth, drawVideoHeight);

            // 3. Dessine le cadre par-dessus la photo sur le canvas
            // Vérifie que l'image du cadre est bien chargée avant de la dessiner
            if (frameOverlay.complete && frameOverlay.naturalWidth > 0) {
                // Dessine le cadre sur toute la surface du canvas (qui est la zone de découpe)
                context.drawImage(frameOverlay, 0, 0, photoCanvas.width, photoCanvas.height);
            } else {
                console.warn("L'image du cadre n'est pas encore chargée ou est invalide. Assurez-vous que 'Cadre photo png.jpg' est dans le bon dossier.");
                alert("Le cadre n'a pas pu être appliqué. La photo a été prise sans cadre.");
            }

            // 4. Récupère la photo finale du canvas sous forme d'URL de données (Base64)
            photoDataUrl = photoCanvas.toDataURL('image/png');
            downloadBtn.disabled = false; // Active le bouton de téléchargement
        });

        // Écouteur d'événement pour le bouton "Changer de caméra"
        flipCameraBtn.addEventListener('click', async () => {
            if (videoInputDevices.length <= 1) {
                console.log("Moins de 2 caméras disponibles, impossible de changer.");
                return;
            }

            // Trouver l'index de la caméra actuelle
            const currentIndex = videoInputDevices.findIndex(device => device.deviceId === currentCameraId);
            // Calculer l'index de la prochaine caméra
            const nextIndex = (currentIndex + 1) % videoInputDevices.length;
            const nextCamera = videoInputDevices[nextIndex];

            currentCameraId = nextCamera.deviceId; // Met à jour l'ID de la caméra actuelle
            await startWebcam(currentCameraId); // Démarre la webcam avec la nouvelle caméra
        });


        // Écouteur d'événement pour le bouton "Télécharger"
        downloadBtn.addEventListener('click', () => {
            if (photoDataUrl) {
                // Crée un élément <a> temporaire pour le téléchargement
                const link = document.createElement('a');
                link.href = photoDataUrl; // L'URL de la photo
                link.download = 'Ma_Photo_Souvenir_La_Reunion.png'; // Nom du fichier à télécharger
                document.body.appendChild(link); // Ajoute le lien au corps du document
                link.click(); // Simule un clic sur le lien pour déclencher le téléchargement
                document.body.removeChild(link); // Supprime le lien temporaire
            }
        });

        // Démarrer la webcam et énumérer les caméras au chargement complet de la page
        window.addEventListener('load', async () => {
            setWebcamAndCanvasPosition(); // Définir la position initiale de la webcam/canvas
            await enumerateCameras(); // Énumère les caméras avant de démarrer
            await startWebcam(); // Démarre la webcam (utilisera la première ou la frontale par défaut)
        });

        // Met à jour la position et la taille de la webcam/canvas lors du redimensionnement de la fenêtre
        window.addEventListener('resize', setWebcamAndCanvasPosition);

        // Arrêter le flux de la webcam lorsque l'utilisateur quitte ou ferme la page
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop()); // Arrête toutes les pistes du flux
            }
        });

        // Enregistrement du Service Worker (pour la fonctionnalité PWA)
        // Vérifie si le navigateur supporte les Service Workers
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Tente d'enregistrer le Service Worker
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker enregistré avec succès:', registration);
                    })
                    .catch(error => {
                        console.error('Échec de l\'enregistrement du Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>

