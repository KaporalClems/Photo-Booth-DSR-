<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth La Réunion</title>

    <!-- Styles CSS intégrés -->
    <style>
        /* Styles généraux pour le corps de la page */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Prend au moins toute la hauteur de la fenêtre */
            margin: 0; /* Supprime les marges par défaut du corps */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Police de caractères moderne */
            background-color: #e0f2f7; /* Un bleu clair apaisant pour l'arrière-plan */
            color: #333; /* Couleur de texte foncée */
        }

        /* Conteneur principal de l'application Photo Booth */
        .photo-booth-container {
            background-color: #ffffff; /* Fond blanc pour le conteneur */
            padding: 20px; /* Espacement interne */
            border-radius: 12px; /* Coins arrondis */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Ombre portée pour un effet de profondeur */
            text-align: center; /* Centre le texte et les éléments à l'intérieur */
            max-width: 500px; /* Largeur maximale ajustée pour mieux correspondre au cadre portrait */
            width: 90%; /* S'adapte à la largeur de l'écran (responsive) */
            border: 2px solid #007bff; /* Bordure thématique bleue */
            display: flex; /* Utilise flexbox pour l'agencement interne */
            flex-direction: column; /* Les éléments s'empilent verticalement */
            align-items: center; /* Centre les éléments horizontalement */
        }

        /* Conteneur pour la vidéo, le canvas et les boutons */
        .video-wrapper {
            position: relative; /* Permet le positionnement absolu des enfants */
            width: 100%; /* Prend toute la largeur disponible */
            /* Ratio d'aspect ajusté pour correspondre au cadre (720x960 -> 3:4 portrait) */
            padding-bottom: calc(960 / 720 * 100%); /* Hauteur = 4/3 de la largeur */
            height: 0; /* Hauteur initiale à 0, la hauteur est gérée par padding-bottom */
            margin-bottom: 25px; /* Marge sous le wrapper vidéo */
            overflow: hidden; /* Cache tout ce qui dépasse */
            border-radius: 8px; /* Coins arrondis */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15); /* Légère ombre */
        }

        /* Élément vidéo de la webcam */
        #webcam-feed {
            position: absolute; /* Positionne l'élément par rapport à son parent (.video-wrapper) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Assure que la vidéo remplit l'espace sans déformation */
            transform: scaleX(-1); /* Effet miroir pour que l'utilisateur se voie comme dans un miroir */
            border-radius: 8px; /* Coins arrondis */
            z-index: 1; /* Assure qu'il est en dessous du cadre et des boutons */
        }

        /* Élément canvas pour dessiner la photo et le cadre */
        #photo-canvas {
            position: absolute; /* Positionne l'élément par rapport à son parent (.video-wrapper) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px; /* Coins arrondis */
            z-index: 2; /* Au-dessus de la vidéo, en dessous des boutons */
        }

        /* Conteneur des boutons de contrôle */
        .controls {
            position: absolute; /* Positionne les boutons par rapport à .video-wrapper */
            bottom: 20px; /* 20px du bas du cadre */
            left: 50%; /* Centre horizontalement */
            transform: translateX(-50%); /* Ajuste le centrage parfait */
            display: flex; /* Utilise Flexbox pour aligner les boutons */
            gap: 15px; /* Espace entre les boutons */
            z-index: 3; /* Au-dessus du canvas et de la vidéo */
        }

        /* Styles des boutons */
        .controls button {
            padding: 10px 20px; /* Espacement interne des boutons */
            font-size: 1em; /* Taille de police des boutons */
            cursor: pointer; /* Indique que l'élément est cliquable */
            border: none; /* Supprime la bordure par défaut */
            border-radius: 6px; /* Coins arrondis */
            background-color: #28a745; /* Couleur verte pour "Prendre Photo" */
            color: white; /* Texte blanc */
            transition: background-color 0.3s ease, transform 0.1s ease; /* Transitions douces pour les effets */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre par défaut */
        }

        /* Style spécifique pour le bouton "Télécharger" */
        .controls button#download-btn {
            background-color: #007bff; /* Couleur bleue pour "Télécharger" */
        }

        /* Effet au survol des boutons (sauf s'ils sont désactivés) */
        .controls button:hover:not(:disabled) {
            transform: translateY(-2px); /* Légère élévation au survol */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15); /* Ombre plus prononcée au survol */
        }

        /* Effet au clic des boutons (sauf s'ils sont désactivés) */
        .controls button:active:not(:disabled) {
            transform: translateY(0); /* Retour à la position normale au clic */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Ombre plus légère au clic */
        }

        /* Style des boutons désactivés */
        .controls button:disabled {
            background-color: #cccccc; /* Couleur grise pour les boutons désactivés */
            cursor: not-allowed; /* Curseur "non autorisé" */
            box-shadow: none; /* Pas d'ombre */
            transform: none; /* Pas de transformation */
        }

        /* Ajustements responsifs pour les petits écrans (smartphones) */
        @media (max-width: 600px) {
            .photo-booth-container {
                padding: 15px; /* Réduit le padding sur les petits écrans */
            }

            .controls {
                flex-direction: column; /* Les boutons s'empilent verticalement */
                gap: 10px; /* Réduit l'espace entre les boutons empilés */
                bottom: 15px; /* Ajuste la position des boutons */
            }

            .controls button {
                width: 100%; /* Les boutons prennent toute la largeur disponible */
                padding: 10px 15px; /* Ajuste le padding des boutons */
                font-size: 0.9em; /* Réduit la taille de la police des boutons */
            }
        }
    </style>

    <!-- Manifest de l'application pour PWA (Progressive Web App) -->
    <!-- Ce fichier doit être créé séparément dans le même dossier -->
    <link rel="manifest" href="manifest.json">
</head>
<body>
    <div class="photo-booth-container">
        <!-- Le titre <h1> a été supprimé comme demandé -->
        
        <div class="video-wrapper">
            <!-- Élément vidéo pour afficher le flux de la webcam -->
            <video id="webcam-feed" autoplay playsinline></video>
            <!-- Élément canvas où la photo sera capturée et le cadre appliqué -->
            <canvas id="photo-canvas"></canvas>
            <!-- L'image du cadre est chargée ici mais cachée. Elle sera dessinée sur le canvas via JavaScript. -->
            <img id="frame-overlay" src="Cadre photo png.jpg" alt="Cadre Photo" style="display: none;">

            <!-- Conteneur des boutons de contrôle positionné par-dessus le cadre -->
            <div class="controls">
                <!-- Bouton pour prendre la photo -->
                <button id="take-photo-btn">Prendre Photo</button>
                <!-- Bouton pour télécharger la photo, désactivé par défaut -->
                <button id="download-btn" disabled>Télécharger</button>
            </div>
        </div>
    </div>

    <!-- Logique JavaScript intégrée -->
    <script>
        // Récupération des éléments du DOM
        const webcamFeed = document.getElementById('webcam-feed');
        const photoCanvas = document.getElementById('photo-canvas');
        const context = photoCanvas.getContext('2d'); // Contexte de dessin 2D du canvas
        const takePhotoBtn = document.getElementById('take-photo-btn');
        const downloadBtn = document.getElementById('download-btn');
        const frameOverlay = document.getElementById('frame-overlay'); // L'élément <img> du cadre

        let stream; // Variable pour stocker le flux vidéo de la webcam
        let photoDataUrl; // Variable pour stocker l'URL de la photo prise (format base64)

        // Fonction asynchrone pour démarrer la webcam
        async function startWebcam() {
            try {
                // Demande l'accès à la caméra de l'utilisateur (frontale)
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                webcamFeed.srcObject = stream; // Associe le flux à l'élément vidéo
                webcamFeed.onloadedmetadata = () => {
                    // Une fois que la vidéo est chargée et que ses métadonnées sont disponibles
                    // Ajuste la taille du canvas pour qu'elle corresponde à la résolution de la vidéo
                    photoCanvas.width = webcamFeed.videoWidth;
                    photoCanvas.height = webcamFeed.videoHeight;
                    console.log(`Webcam feed dimensions: ${webcamFeed.videoWidth}x${webcamFeed.videoHeight}`);
                    console.log(`Canvas dimensions set to: ${photoCanvas.width}x${photoCanvas.height}`);
                };
            } catch (error) {
                // Gère les erreurs si l'accès à la webcam est refusé ou impossible
                console.error("Erreur d'accès à la webcam :", error);
                alert("Impossible d'accéder à votre webcam. Veuillez vérifier les permissions de votre navigateur et assurez-vous que le site est servi via HTTPS.");
            }
        }

        // Écouteur d'événement pour le bouton "Prendre Photo"
        takePhotoBtn.addEventListener('click', () => {
            if (!stream) {
                // Empêche de prendre une photo si la webcam n'est pas démarrée
                alert("La webcam n'est pas démarrée. Veuillez patienter ou recharger la page.");
                return;
            }

            // 1. Nettoie le canvas avant de dessiner
            context.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
            
            // 2. Dessine le cadre par-dessus la photo (il sera la base)
            // Vérifie que l'image du cadre est bien chargée avant de la dessiner
            if (frameOverlay.complete && frameOverlay.naturalWidth > 0) {
                // Dessine le cadre sur toute la surface du canvas
                context.drawImage(frameOverlay, 0, 0, photoCanvas.width, photoCanvas.height);

                // 3. Calcule les dimensions de la zone où la webcam doit être dessinée
                // Ces valeurs sont estimées à partir de l'image 'Cadre photo png.jpg' (720x960)
                // et représentent la zone transparente du cadre.
                const originalFrameWidth = 720;
                const originalFrameHeight = 960;
                const originalCutoutX = 100; // Position X du début de la zone transparente
                const originalCutoutY = 280; // Position Y du début de la zone transparente
                const originalCutoutWidth = 520; // Largeur de la zone transparente
                const originalCutoutHeight = 400; // Hauteur de la zone transparente

                // Calcule le facteur d'échelle pour adapter les coordonnées originales à la taille actuelle du canvas
                const scaleFactor = photoCanvas.width / originalFrameWidth;

                const targetX = originalCutoutX * scaleFactor;
                const targetY = originalCutoutY * scaleFactor;
                const targetWidth = originalCutoutWidth * scaleFactor;
                const targetHeight = originalCutoutHeight * scaleFactor;

                // 4. Dessine le flux vidéo de la webcam dans la zone calculée, en maintenant son ratio d'aspect
                const videoAspectRatio = webcamFeed.videoWidth / webcamFeed.videoHeight;
                const targetAspectRatio = targetWidth / targetHeight;

                let drawVideoWidth = targetWidth;
                let drawVideoHeight = targetHeight;
                let drawVideoX = targetX;
                let drawVideoY = targetY;

                if (videoAspectRatio > targetAspectRatio) {
                    // La vidéo est plus large que la zone cible, on l'ajuste par la hauteur et on la centre horizontalement
                    drawVideoHeight = targetHeight;
                    drawVideoWidth = targetHeight * videoAspectRatio;
                    drawVideoX = targetX + (targetWidth - drawVideoWidth) / 2;
                } else {
                    // La vidéo est plus haute que la zone cible, on l'ajuste par la largeur et on la centre verticalement
                    drawVideoWidth = targetWidth;
                    drawVideoHeight = targetWidth / videoAspectRatio;
                    drawVideoY = targetY + (targetHeight - drawVideoHeight) / 2;
                }

                // Dessine le flux webcam (avec effet miroir) dans la zone calculée
                context.save(); // Sauvegarde l'état actuel du contexte
                context.scale(-1, 1); // Applique un miroir horizontal
                // Le '-drawVideoX - drawVideoWidth' est dû à la transformation miroir pour positionner correctement
                context.drawImage(webcamFeed, -drawVideoX - drawVideoWidth, drawVideoY, drawVideoWidth, drawVideoHeight);
                context.restore(); // Restaure l'état du contexte (supprime la transformation miroir)

            } else {
                console.warn("L'image du cadre n'est pas encore chargée ou est invalide. Assurez-vous que 'Cadre photo png.jpg' est dans le bon dossier.");
                alert("Le cadre n'a pas pu être appliqué. La photo a été prise sans cadre.");
                // Si le cadre ne peut pas être chargé, dessine juste la webcam (miroir)
                context.save();
                context.scale(-1, 1);
                context.drawImage(webcamFeed, -photoCanvas.width, 0, photoCanvas.width, photoCanvas.height);
                context.restore();
            }

            // 5. Récupère la photo finale du canvas sous forme d'URL de données (Base64)
            photoDataUrl = photoCanvas.toDataURL('image/png');
            downloadBtn.disabled = false; // Active le bouton de téléchargement
        });

        // Écouteur d'événement pour le bouton "Télécharger"
        downloadBtn.addEventListener('click', () => {
            if (photoDataUrl) {
                // Crée un élément <a> temporaire pour le téléchargement
                const link = document.createElement('a');
                link.href = photoDataUrl; // L'URL de la photo
                link.download = 'Ma_Photo_Souvenir_La_Reunion.png'; // Nom du fichier à télécharger
                document.body.appendChild(link); // Ajoute le lien au corps du document
                link.click(); // Simule un clic sur le lien pour déclencher le téléchargement
                document.body.removeChild(link); // Supprime le lien temporaire
            }
        });

        // Démarrer la webcam automatiquement au chargement complet de la page
        window.addEventListener('load', startWebcam);

        // Arrêter le flux de la webcam lorsque l'utilisateur quitte ou ferme la page
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop()); // Arrête toutes les pistes du flux
            }
        });

        // Enregistrement du Service Worker (pour la fonctionnalité PWA)
        // Vérifie si le navigateur supporte les Service Workers
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Tente d'enregistrer le Service Worker
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker enregistré avec succès:', registration);
                    })
                    .catch(error => {
                        console.error('Échec de l\'enregistrement du Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
