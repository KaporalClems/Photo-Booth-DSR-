<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth DSR</title>
    <!-- Tailwind CSS CDN pour un stylisme rapide et réactif -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Police Inter pour une meilleure lisibilité -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Lien vers le manifest de la PWA -->
    <link rel="manifest" href="manifest.json">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Couleur de fond par défaut */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            color: #333;
            /* Le cadre sera appliqué dynamiquement au canvas, pas au body */
        }
        .app-container {
            position: relative; /* Pour positionner les éléments à l'intérieur */
            width: 100%;
            max-width: 744px; /* Largeur naturelle de votre cadre */
            aspect-ratio: 744 / 1052; /* Ratio de votre cadre (largeur / hauteur) */
            background-color: #000; /* Fond noir derrière la zone de la photo */
            border-radius: 1.5rem; /* Coins arrondis pour l'ensemble */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* S'assure que le contenu ne dépasse pas */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 1.5rem; /* Marge autour du conteneur principal */
        }
        #canvas, #photoPreview {
            position: absolute; /* Le canvas et la photo preview remplissent le conteneur */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block; /* Supprime l'espace sous l'élément */
            object-fit: contain; /* Assure que le contenu s'adapte sans déformation */
        }
        #video {
            display: none; /* La vidéo est cachée, son flux est dessiné sur le canvas */
        }
        .controls {
            position: absolute;
            bottom: 1rem; /* Positionne les contrôles en bas de l'app-container */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            width: 90%; /* Prend une bonne partie de la largeur */
            z-index: 10; /* S'assure que les boutons sont au-dessus du canvas */
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem; /* Coins arrondis pour les boutons */
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .button-primary {
            background-color: #4f46e5; /* Indigo */
            color: white;
        }
        .button-primary:hover {
            background-color: #4338ca;
        }
        .button-secondary {
            background-color: #6b7280; /* Gris */
            color: white;
        }
        .button-secondary:hover {
            background-color: #4b5563;
        }
        .button-success {
            background-color: #10b981; /* Vert */
            color: white;
        }
        .button-success:hover {
            background-color: #059669;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            z-index: 1000;
            display: none; /* Caché par défaut */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        .message-box button {
            margin-top: 1rem;
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        .message-box button:hover {
            background-color: #4338ca;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="app-container">
        <h1 class="text-3xl font-bold text-indigo-700 mb-4 absolute top-4 z-10" style="color: #4f46e5; text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Photo Booth DSR</h1>

        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button onclick="hideMessageBox()">OK</button>
        </div>

        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        <img id="photoPreview" class="hidden" alt="Photo prise">

        <div class="controls">
            <button id="startCameraButton" class="button-primary">Ouvrir la Caméra</button>
            <button id="takePhotoButton" class="button-primary hidden">Prendre la Photo</button>
            <button id="downloadPhotoButton" class="button-success hidden">Télécharger la Photo</button>
            <button id="retakePhotoButton" class="button-secondary hidden">Reprendre</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const photoPreview = document.getElementById('photoPreview');
        const startCameraButton = document.getElementById('startCameraButton');
        const takePhotoButton = document.getElementById('takePhotoButton');
        const downloadPhotoButton = document.getElementById('downloadPhotoButton');
        const retakePhotoButton = document.getElementById('retakePhotoButton');
        const appContainer = document.querySelector('.app-container');

        let currentStream;
        let capturedPhotoBlob = null;
        let mainFrameImage = new Image();
        // Assurez-vous que le chemin de l'image est correct par rapport à votre déploiement GitHub
        mainFrameImage.src = 'Cadre photo png.jpg';

        // Coordonnées du "trou" transparent dans votre image de cadre (estimées en pixels pour une image de 744x1052)
        // Ces valeurs sont cruciales et peuvent nécessiter un ajustement fin si le cadre n'apparaît pas parfaitement aligné.
        const HOLE_X = 111; // Position X du coin supérieur gauche du trou
        const HOLE_Y = 263; // Position Y du coin supérieur gauche du trou
        const HOLE_WIDTH = 520; // Largeur du trou
        const HOLE_HEIGHT = 473; // Hauteur du trou

        // Fonction pour afficher une boîte de message personnalisée
        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        // Fonction pour masquer la boîte de message
        function hideMessageBox() {
            document.getElementById('messageBox').style.display = 'none';
        }

        // Dessine le cadre principal sur le canvas
        function drawMainFrame() {
            // S'assurer que le canvas a les dimensions de l'image du cadre pour un rendu optimal
            canvas.width = mainFrameImage.naturalWidth;
            canvas.height = mainFrameImage.naturalHeight;

            // Dessiner le cadre en premier
            context.drawImage(mainFrameImage, 0, 0, canvas.width, canvas.height);
        }

        // Fonction pour démarrer la caméra
        startCameraButton.addEventListener('click', async () => {
            try {
                // Demander l'accès à la caméra
                currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }); // 'environment' pour la caméra arrière
                video.srcObject = currentStream;
                video.play();

                // Cacher le bouton "Ouvrir la Caméra" et montrer "Prendre la Photo"
                startCameraButton.classList.add('hidden');
                takePhotoButton.classList.remove('hidden');
                photoPreview.classList.add('hidden'); // Cacher la photo précédente
                downloadPhotoButton.classList.add('hidden');
                retakePhotoButton.classList.add('hidden');
                canvas.classList.remove('hidden'); // S'assurer que le canvas est visible

                // Dessiner le cadre sur le canvas dès que la caméra est prête
                mainFrameImage.onload = () => {
                    drawMainFrame();
                    // Commencer à dessiner le flux vidéo sur le canvas
                    requestAnimationFrame(drawVideoOnCanvas);
                };
                // Si l'image est déjà chargée, dessiner immédiatement
                if (mainFrameImage.complete) {
                    drawMainFrame();
                    requestAnimationFrame(drawVideoOnCanvas);
                }

            } catch (err) {
                console.error("Erreur d'accès à la caméra: ", err);
                showMessageBox("Impossible d'accéder à la caméra. Veuillez autoriser l'accès.");
            }
        });

        // Fonction pour dessiner le flux vidéo en continu sur le canvas
        function drawVideoOnCanvas() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Dessiner d'abord le cadre pour effacer le contenu précédent et s'assurer qu'il est en arrière-plan
                drawMainFrame();

                // Calculer les dimensions pour dessiner la vidéo dans le "trou" avec object-fit: cover
                let sx, sy, sWidth, sHeight; // Source (vidéo)
                let dx, dy, dWidth, dHeight; // Destination (canvas, le trou)

                // Dimensions de destination (le trou dans le cadre)
                dx = HOLE_X;
                dy = HOLE_Y;
                dWidth = HOLE_WIDTH;
                dHeight = HOLE_HEIGHT;

                // Calculer les dimensions source pour "couvrir" le trou avec la vidéo
                const holeAspectRatio = dWidth / dHeight;
                const videoAspectRatio = video.videoWidth / video.videoHeight;

                if (videoAspectRatio > holeAspectRatio) {
                    // La vidéo est plus large que le trou, couper en haut/bas de la vidéo
                    sHeight = video.videoHeight;
                    sWidth = sHeight * holeAspectRatio;
                    sx = (video.videoWidth - sWidth) / 2;
                    sy = 0;
                } else {
                    // La vidéo est plus haute que le trou, couper à gauche/droite de la vidéo
                    sWidth = video.videoWidth;
                    sHeight = sWidth / holeAspectRatio;
                    sx = 0;
                    sy = (video.videoHeight - sHeight) / 2;
                }

                // Dessiner la vidéo dans le trou du cadre
                context.drawImage(video, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
            }
            // Continuer l'animation
            if (!video.classList.contains('hidden')) { // S'assurer que la vidéo est toujours active
                 requestAnimationFrame(drawVideoOnCanvas);
            }
        }

        // Fonction pour prendre la photo
        takePhotoButton.addEventListener('click', () => {
            // Le canvas contient déjà le cadre et la vidéo correctement dessinés
            // Arrêter le flux de la caméra
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            // Afficher la photo finale sur l'élément img
            photoPreview.src = canvas.toDataURL('image/png');
            photoPreview.classList.remove('hidden');
            canvas.classList.add('hidden'); // Cacher le canvas une fois la photo prise

            // Mettre à jour les boutons
            takePhotoButton.classList.add('hidden');
            downloadPhotoButton.classList.remove('hidden');
            retakePhotoButton.classList.remove('hidden');

            // Stocker le Blob pour le téléchargement
            canvas.toBlob(blob => {
                capturedPhotoBlob = blob;
            }, 'image/png');
        });

        // Fonction pour télécharger la photo
        downloadPhotoButton.addEventListener('click', () => {
            if (capturedPhotoBlob) {
                const url = URL.createObjectURL(capturedPhotoBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'photobooth_dsr.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Libérer l'URL de l'objet
                showMessageBox("Photo téléchargée !");
            } else {
                showMessageBox("Aucune photo à télécharger.");
            }
        });

        // Fonction pour reprendre une photo
        retakePhotoButton.addEventListener('click', () => {
            // Réinitialiser l'état
            photoPreview.classList.add('hidden');
            downloadPhotoButton.classList.add('hidden');
            retakePhotoButton.classList.add('hidden');
            startCameraButton.classList.remove('hidden'); // Montrer le bouton pour redémarrer la caméra
            capturedPhotoBlob = null; // Réinitialiser le blob de la photo
            canvas.classList.remove('hidden'); // Afficher le canvas pour le prochain démarrage de la caméra

            // Redessiner le cadre sur le canvas pour un état initial propre
            drawMainFrame();
        });

        // Initialiser l'affichage du cadre sur le canvas au chargement
        mainFrameImage.onerror = () => {
            console.error("Erreur de chargement de l'image du cadre principal: Cadre photo png.jpg");
            showMessageBox("Impossible de charger l'image du cadre principal. Veuillez vérifier le chemin.");
        };

        // Dessiner le cadre initialement (avant le démarrage de la caméra)
        mainFrameImage.onload = () => {
            drawMainFrame();
        };
        // Si l'image est déjà chargée (par exemple, depuis le cache), dessiner immédiatement
        if (mainFrameImage.complete) {
            drawMainFrame();
        }

        // Enregistrement du Service Worker pour la PWA
        // Ce bloc de code est commenté pour éviter les erreurs dans l'environnement de prévisualisation.
        // DÉCOMMENTEZ-LE LORS DU DÉPLOIEMENT SUR UN SERVEUR WEB (comme GitHub Pages)
        // pour que la PWA fonctionne pleinement et offre des fonctionnalités hors ligne.
        /*
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker enregistré avec succès:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Échec de l\'enregistrement du ServiceWorker:', error);
                    });
            });
        }
        */
    </script>
</body>
</html>

