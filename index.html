<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth La Réunion</title>

    <!-- Styles CSS intégrés -->
    <style>
        /* Styles généraux pour le corps de la page */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Prend au moins toute la hauteur de la fenêtre */
            margin: 0; /* Supprime les marges par défaut du corps */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Police de caractères moderne */
            background-color: #e0f2f7; /* Un bleu clair apaisant pour l'arrière-plan */
            color: #333; /* Couleur de texte foncée */
        }

        /* Conteneur principal de l'application Photo Booth */
        .photo-booth-container {
            background-color: #ffffff; /* Fond blanc pour le conteneur */
            padding: 30px; /* Espacement interne */
            border-radius: 12px; /* Coins arrondis */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Ombre portée pour un effet de profondeur */
            text-align: center; /* Centre le texte et les éléments à l'intérieur */
            max-width: 700px; /* Largeur maximale pour éviter un étirement excessif sur grands écrans */
            width: 90%; /* S'adapte à la largeur de l'écran (responsive) */
            border: 2px solid #007bff; /* Bordure thématique bleue */
        }

        /* Titre de l'application */
        h1 {
            color: #0056b3; /* Couleur bleue foncée pour le titre */
            margin-bottom: 25px; /* Marge sous le titre */
            font-size: 2em; /* Taille de police plus grande */
        }

        /* Conteneur pour la vidéo et le canvas */
        .video-wrapper {
            position: relative; /* Permet le positionnement absolu des enfants */
            width: 100%; /* Prend toute la largeur disponible */
            padding-bottom: 66.66%; /* Ratio 3:2 (hauteur = 2/3 de la largeur) pour la vidéo, ajuste si ta vidéo est 4:3 ou autre */
            height: 0; /* Hauteur initiale à 0, la hauteur est gérée par padding-bottom */
            margin-bottom: 25px; /* Marge sous le wrapper vidéo */
            overflow: hidden; /* Cache tout ce qui dépasse */
            border-radius: 8px; /* Coins arrondis */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15); /* Légère ombre */
        }

        /* Élément vidéo de la webcam */
        #webcam-feed {
            position: absolute; /* Positionne l'élément par rapport à son parent (.video-wrapper) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Assure que la vidéo remplit l'espace sans déformation */
            transform: scaleX(-1); /* Effet miroir pour que l'utilisateur se voie comme dans un miroir */
            border-radius: 8px; /* Coins arrondis */
        }

        /* Élément canvas pour dessiner la photo et le cadre */
        #photo-canvas {
            position: absolute; /* Positionne l'élément par rapport à son parent (.video-wrapper) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px; /* Coins arrondis */
            /* Le canvas est transparent par défaut, on y dessinera la vidéo et le cadre */
        }

        /* Conteneur des boutons de contrôle */
        .controls {
            display: flex; /* Utilise Flexbox pour aligner les boutons */
            justify-content: center; /* Centre les boutons horizontalement */
            gap: 20px; /* Espace entre les boutons */
            margin-top: 20px; /* Marge au-dessus des boutons */
        }

        /* Styles des boutons */
        .controls button {
            padding: 12px 25px; /* Espacement interne des boutons */
            font-size: 1.1em; /* Taille de police des boutons */
            cursor: pointer; /* Indique que l'élément est cliquable */
            border: none; /* Supprime la bordure par défaut */
            border-radius: 6px; /* Coins arrondis */
            background-color: #28a745; /* Couleur verte pour "Prendre Photo" */
            color: white; /* Texte blanc */
            transition: background-color 0.3s ease, transform 0.1s ease; /* Transitions douces pour les effets */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre par défaut */
        }

        /* Style spécifique pour le bouton "Télécharger" */
        .controls button#download-btn {
            background-color: #007bff; /* Couleur bleue pour "Télécharger" */
        }

        /* Effet au survol des boutons (sauf s'ils sont désactivés) */
        .controls button:hover:not(:disabled) {
            transform: translateY(-2px); /* Légère élévation au survol */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15); /* Ombre plus prononcée au survol */
        }

        /* Effet au clic des boutons (sauf s'ils sont désactivés) */
        .controls button:active:not(:disabled) {
            transform: translateY(0); /* Retour à la position normale au clic */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Ombre plus légère au clic */
        }

        /* Style des boutons désactivés */
        .controls button:disabled {
            background-color: #cccccc; /* Couleur grise pour les boutons désactivés */
            cursor: not-allowed; /* Curseur "non autorisé" */
            box-shadow: none; /* Pas d'ombre */
            transform: none; /* Pas de transformation */
        }

        /* Ajustements responsifs pour les petits écrans (smartphones) */
        @media (max-width: 600px) {
            .photo-booth-container {
                padding: 15px; /* Réduit le padding sur les petits écrans */
            }

            h1 {
                font-size: 1.5em; /* Réduit la taille du titre */
            }

            .controls {
                flex-direction: column; /* Les boutons s'empilent verticalement */
                gap: 10px; /* Réduit l'espace entre les boutons empilés */
            }

            .controls button {
                width: 100%; /* Les boutons prennent toute la largeur disponible */
            }
        }
    </style>

    <!-- Manifest de l'application pour PWA (Progressive Web App) -->
    <!-- Ce fichier doit être créé séparément dans le même dossier -->
    <link rel="manifest" href="manifest.json">
</head>
<body>
    <div class="photo-booth-container">
        <h1>Photo Booth La Réunion</h1>
        
        <div class="video-wrapper">
            <!-- Élément vidéo pour afficher le flux de la webcam -->
            <video id="webcam-feed" autoplay playsinline></video>
            <!-- Élément canvas où la photo sera capturée et le cadre appliqué -->
            <canvas id="photo-canvas"></canvas>
            <!-- L'image du cadre est chargée ici mais cachée. Elle sera dessinée sur le canvas via JavaScript. -->
            <img id="frame-overlay" src="Cadre photo png.jpg" alt="Cadre Photo" style="display: none;">
        </div>

        <div class="controls">
            <!-- Bouton pour prendre la photo -->
            <button id="take-photo-btn">Prendre Photo</button>
            <!-- Bouton pour télécharger la photo, désactivé par défaut -->
            <button id="download-btn" disabled>Télécharger</button>
        </div>
    </div>

    <!-- Logique JavaScript intégrée -->
    <script>
        // Récupération des éléments du DOM
        const webcamFeed = document.getElementById('webcam-feed');
        const photoCanvas = document.getElementById('photo-canvas');
        const context = photoCanvas.getContext('2d'); // Contexte de dessin 2D du canvas
        const takePhotoBtn = document.getElementById('take-photo-btn');
        const downloadBtn = document.getElementById('download-btn');
        const frameOverlay = document.getElementById('frame-overlay'); // L'élément <img> du cadre

        let stream; // Variable pour stocker le flux vidéo de la webcam
        let photoDataUrl; // Variable pour stocker l'URL de la photo prise (format base64)

        // Fonction asynchrone pour démarrer la webcam
        async function startWebcam() {
            try {
                // Demande l'accès à la caméra de l'utilisateur (frontale)
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                webcamFeed.srcObject = stream; // Associe le flux à l'élément vidéo
                webcamFeed.onloadedmetadata = () => {
                    // Une fois que la vidéo est chargée et que ses métadonnées sont disponibles
                    // Ajuste la taille du canvas pour qu'elle corresponde à la résolution de la vidéo
                    photoCanvas.width = webcamFeed.videoWidth;
                    photoCanvas.height = webcamFeed.videoHeight;
                    console.log(`Webcam feed dimensions: ${webcamFeed.videoWidth}x${webcamFeed.videoHeight}`);
                    console.log(`Canvas dimensions set to: ${photoCanvas.width}x${photoCanvas.height}`);
                };
            } catch (error) {
                // Gère les erreurs si l'accès à la webcam est refusé ou impossible
                console.error("Erreur d'accès à la webcam :", error);
                alert("Impossible d'accéder à votre webcam. Veuillez vérifier les permissions de votre navigateur et assurez-vous que le site est servi via HTTPS.");
            }
        }

        // Écouteur d'événement pour le bouton "Prendre Photo"
        takePhotoBtn.addEventListener('click', () => {
            if (!stream) {
                // Empêche de prendre une photo si la webcam n'est pas démarrée
                alert("La webcam n'est pas démarrée. Veuillez patienter ou recharger la page.");
                return;
            }

            // 1. Nettoie le canvas avant de dessiner
            context.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
            
            // 2. Dessine le flux vidéo de la webcam sur le canvas
            // Applique la transformation miroir pour que la photo corresponde à ce que l'utilisateur voit
            context.save(); // Sauvegarde l'état actuel du contexte
            context.scale(-1, 1); // Applique un miroir horizontal
            // Dessine l'image de la vidéo sur le canvas. Le '-photoCanvas.width' est dû à la transformation miroir.
            context.drawImage(webcamFeed, -photoCanvas.width, 0, photoCanvas.width, photoCanvas.height);
            context.restore(); // Restaure l'état du contexte (supprime la transformation miroir pour les dessins suivants)

            // 3. Dessine le cadre par-dessus la photo
            // Vérifie que l'image du cadre est bien chargée avant de la dessiner
            if (frameOverlay.complete && frameOverlay.naturalWidth > 0) {
                // IMPORTANT : Ajuste ces valeurs (frameX, frameY, frameWidth, frameHeight)
                // pour que ton cadre s'adapte parfaitement à ton image 'Cadre photo png.jpg'
                // et à la zone où tu veux qu'il apparaisse sur la photo finale.

                // Si ton cadre PNG est conçu pour couvrir toute la surface du canvas
                // avec des zones transparentes pour la photo, utilise ces valeurs:
                const frameX = 0;
                const frameY = 0;
                const frameWidth = photoCanvas.width;
                const frameHeight = photoCanvas.height;
                
                // Si ton cadre est plus petit et doit être centré ou positionné spécifiquement,
                // tu devras calculer ces valeurs. Par exemple:
                /*
                const framePadding = 50; // Marge intérieure du cadre
                const frameX = framePadding;
                const frameY = framePadding;
                const frameWidth = photoCanvas.width - (2 * framePadding);
                const frameHeight = photoCanvas.height - (2 * framePadding);
                */

                context.drawImage(frameOverlay, frameX, frameY, frameWidth, frameHeight);
            } else {
                console.warn("L'image du cadre n'est pas encore chargée ou est invalide. Assurez-vous que 'Cadre photo png.jpg' est dans le bon dossier.");
                alert("Le cadre n'a pas pu être appliqué. La photo a été prise sans cadre.");
            }

            // 4. Récupère la photo finale du canvas sous forme d'URL de données (Base64)
            photoDataUrl = photoCanvas.toDataURL('image/png');
            downloadBtn.disabled = false; // Active le bouton de téléchargement
        });

        // Écouteur d'événement pour le bouton "Télécharger"
        downloadBtn.addEventListener('click', () => {
            if (photoDataUrl) {
                // Crée un élément <a> temporaire pour le téléchargement
                const link = document.createElement('a');
                link.href = photoDataUrl; // L'URL de la photo
                link.download = 'Ma_Photo_Souvenir_La_Reunion.png'; // Nom du fichier à télécharger
                document.body.appendChild(link); // Ajoute le lien au corps du document
                link.click(); // Simule un clic sur le lien pour déclencher le téléchargement
                document.body.removeChild(link); // Supprime le lien temporaire
            }
        });

        // Démarrer la webcam automatiquement au chargement complet de la page
        window.addEventListener('load', startWebcam);

        // Arrêter le flux de la webcam lorsque l'utilisateur quitte ou ferme la page
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop()); // Arrête toutes les pistes du flux
            }
        });

        // Enregistrement du Service Worker (pour la fonctionnalité PWA)
        // Vérifie si le navigateur supporte les Service Workers
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Tente d'enregistrer le Service Worker
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker enregistré avec succès:', registration);
                    })
                    .catch(error => {
                        console.error('Échec de l\'enregistrement du Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
