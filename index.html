<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth La Réunion</title>

    <!-- Font Awesome pour les icônes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

    <!-- Styles CSS intégrés -->
    <style>
        /* Styles généraux pour le corps de la page */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Prend au moins toute la hauteur de la fenêtre */
            margin: 0; /* Supprime les marges par défaut du corps */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Police de caractères moderne */
            /* Applique l'image en fond d'écran */
            background-image: url('Cadre photo png.png'); /* Chemin vers ton image */
            background-size: cover; /* Couvre toute la zone, peut recadrer l'image */
            background-position: center center; /* Centre l'image */
            background-repeat: no-repeat; /* Ne répète pas l'image */
            background-attachment: fixed; /* Fixe l'image en arrière-plan lors du défilement */
            color: #333; /* Couleur de texte foncée */
        }

        /* Conteneur principal de l'application Photo Booth */
        .photo-booth-container {
            background-color: rgba(255, 255, 255, 0.9); /* Fond blanc semi-transparent */
            padding: 20px; /* Espacement interne */
            border-radius: 12px; /* Coins arrondis */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Ombre portée pour un effet de profondeur */
            text-align: center; /* Centre le texte et les éléments à l'intérieur */
            max-width: 500px; /* Largeur maximale ajustée pour mieux correspondre au cadre portrait */
            width: 90%; /* S'adapte à la largeur de l'écran (responsive) */
            /* border: 2px solid #007bff; -- Supprimé comme demandé */
            display: flex; /* Utilise flexbox pour l'agencement interne */
            flex-direction: column; /* Les éléments s'empilent verticalement */
            align-items: center; /* Centre les éléments horizontalement */
        }

        /* Conteneur pour la vidéo, le canvas et les boutons */
        .video-wrapper {
            position: relative; /* Permet le positionnement absolu des enfants */
            width: 100%; /* Prend toute la largeur disponible */
            /* Ratio d'aspect ajusté pour correspondre au cadre (720x960 -> 3:4 portrait) */
            padding-bottom: calc(960 / 720 * 100%); /* Hauteur = 4/3 de la largeur */
            height: 0; /* Hauteur initiale à 0, la hauteur est gérée par padding-bottom */
            /* margin-bottom: 25px; Supprimé car les boutons sont maintenant à l'intérieur */
            overflow: hidden; /* Cache tout ce qui dépasse */
            border-radius: 8px; /* Coins arrondis */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15); /* Légère ombre */
        }

        /* Élément vidéo de la webcam */
        #webcam-feed {
            position: absolute; /* Positionne l'élément par rapport à son parent (.video-wrapper) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Assure que la vidéo remplit l'espace sans déformation */
            transform: scaleX(-1); /* Effet miroir pour que l'utilisateur se voie comme dans un miroir */
            border-radius: 8px; /* Coins arrondis */
            z-index: 1; /* Assure qu'il est en dessous du cadre et des boutons */
        }

        /* Élément canvas pour dessiner la photo et le cadre */
        #photo-canvas {
            position: absolute; /* Positionne l'élément par rapport à son parent (.video-wrapper) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px; /* Coins arrondis */
            z-index: 2; /* Au-dessus de la vidéo, en dessous des boutons */
        }

        /* Styles de base pour tous les boutons d'icônes */
        .icon-button {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.5); /* Fond semi-transparent */
            color: white;
            border: none;
            border-radius: 50%; /* Boutons ronds */
            width: 50px; /* Taille des boutons */
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em; /* Taille de l'icône */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 3; /* Au-dessus du canvas */
        }

        .icon-button:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.05);
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button:disabled {
            background-color: rgba(150, 150, 150, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        /* Positionnement du bouton de prise de photo (icône caméra) */
        #take-photo-btn {
            bottom: 60px; /* Positionné plus haut pour être sur le cadre */
            left: 50%;
            transform: translateX(-50%);
            background-color: #28a745; /* Vert */
        }
        #take-photo-btn:hover {
            background-color: #218838;
        }

        /* Positionnement du bouton de changement de caméra (icône flip) */
        #flip-camera-btn {
            top: 30px; /* Positionné en haut du cadre */
            left: 50%;
            transform: translateX(-50%);
            background-color: #007bff; /* Bleu */
        }
        #flip-camera-btn:hover {
            background-color: #0056b3;
        }

        /* Positionnement du bouton de téléchargement (texte "TÉLÉCHARGER") */
        #download-btn {
            position: absolute; /* Positionné par rapport à .video-wrapper */
            bottom: 20px; /* 20px du bas du cadre */
            right: 20px; /* 20px de la droite du cadre */
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            background-color: #ffc107; /* Jaune */
            color: #333; /* Texte foncé pour le contraste */
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 3; /* Au-dessus du canvas */
        }
        #download-btn:hover:not(:disabled) {
            background-color: #e0a800;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        #download-btn:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #download-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Ajustements responsifs pour les petits écrans (smartphones) */
        @media (max-width: 600px) {
            .photo-booth-container {
                padding: 15px; /* Réduit le padding sur les petits écrans */
            }

            .icon-button {
                width: 45px;
                height: 45px;
                font-size: 1.3em;
            }

            #take-photo-btn {
                bottom: 40px; /* Ajuste la position des boutons */
            }
            #flip-camera-btn {
                top: 20px;
            }
            #download-btn {
                bottom: 15px;
                right: 15px;
                padding: 8px 15px;
                font-size: 0.9em;
            }
        }
    </style>

    <!-- Manifest de l'application pour PWA (Progressive Web App) -->
    <!-- Ce fichier doit être créé séparément dans le même dossier -->
    <link rel="manifest" href="manifest.json">
</head>
<body>
    <div class="photo-booth-container">
        
        <div class="video-wrapper">
            <!-- Élément vidéo pour afficher le flux de la webcam -->
            <video id="webcam-feed" autoplay playsinline></video>
            <!-- Élément canvas où la photo sera capturée et le cadre appliqué -->
            <canvas id="photo-canvas"></canvas>
            <!-- L'image du cadre est chargée ici mais cachée. Elle sera dessinée sur le canvas via JavaScript. -->
            <img id="frame-overlay" src="Cadre photo png.jpg" alt="Cadre Photo" style="display: none;">

            <!-- Bouton pour prendre la photo (icône caméra) -->
            <button id="take-photo-btn" class="icon-button">
                <i class="fas fa-camera"></i>
            </button>

            <!-- Bouton pour changer de caméra (icône flip) -->
            <button id="flip-camera-btn" class="icon-button">
                <i class="fas fa-sync-alt"></i>
            </button>

            <!-- Bouton pour télécharger la photo (texte "TÉLÉCHARGER") -->
            <button id="download-btn" disabled>TÉLÉCHARGER</button>
        </div>
    </div>

    <!-- Logique JavaScript intégrée -->
    <script>
        // Récupération des éléments du DOM
        const webcamFeed = document.getElementById('webcam-feed');
        const photoCanvas = document.getElementById('photo-canvas');
        const context = photoCanvas.getContext('2d'); // Contexte de dessin 2D du canvas
        const takePhotoBtn = document.getElementById('take-photo-btn');
        const flipCameraBtn = document.getElementById('flip-camera-btn'); // Nouveau bouton flip
        const downloadBtn = document.getElementById('download-btn');
        const frameOverlay = document.getElementById('frame-overlay'); // L'élément <img> du cadre

        let stream; // Variable pour stocker le flux vidéo de la webcam
        let photoDataUrl; // Variable pour stocker l'URL de la photo prise (format base64)
        let currentCameraId = null; // ID de la caméra actuellement utilisée
        let videoInputDevices = []; // Liste des caméras disponibles

        // Fonction pour énumérer les caméras disponibles
        async function enumerateCameras() {
            videoInputDevices = [];
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                devices.forEach(device => {
                    if (device.kind === 'videoinput') {
                        videoInputDevices.push(device);
                    }
                });
                // Active/désactive le bouton flip si plus d'une caméra est disponible
                flipCameraBtn.disabled = videoInputDevices.length <= 1;
            } catch (error) {
                console.error("Erreur lors de l'énumération des caméras :", error);
                flipCameraBtn.disabled = true; // Désactive le bouton en cas d'erreur
            }
        }

        // Fonction asynchrone pour démarrer la webcam
        async function startWebcam(deviceId = null) {
            // Arrête le flux précédent si existant
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    facingMode: 'user' // Par défaut, caméra frontale
                }
            };

            if (deviceId) {
                // Si un deviceId est spécifié, l'utilise
                constraints.video = { deviceId: { exact: deviceId } };
            } else if (videoInputDevices.length > 0) {
                // Si pas de deviceId, mais des caméras sont énumérées, utilise la première
                // ou essaie de trouver la caméra frontale par défaut
                const frontCamera = videoInputDevices.find(device => device.label.toLowerCase().includes('front'));
                if (frontCamera) {
                    constraints.video = { deviceId: { exact: frontCamera.deviceId } };
                    currentCameraId = frontCamera.deviceId;
                } else {
                    constraints.video = { deviceId: { exact: videoInputDevices[0].deviceId } };
                    currentCameraId = videoInputDevices[0].deviceId;
                }
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                webcamFeed.srcObject = stream; // Associe le flux à l'élément vidéo
                webcamFeed.onloadedmetadata = () => {
                    // Une fois que la vidéo est chargée et que ses métadonnées sont disponibles
                    // Ajuste la taille du canvas pour qu'elle corresponde à la résolution de la vidéo
                    photoCanvas.width = webcamFeed.videoWidth;
                    photoCanvas.height = webcamFeed.videoHeight;
                    console.log(`Webcam feed dimensions: ${webcamFeed.videoWidth}x${webcamFeed.videoHeight}`);
                    console.log(`Canvas dimensions set to: ${photoCanvas.width}x${photoCanvas.height}`);
                };
            } catch (error) {
                console.error("Erreur d'accès à la webcam :", error);
                alert("Impossible d'accéder à votre webcam. Veuillez vérifier les permissions de votre navigateur et assurez-vous que le site est servi via HTTPS.");
                // Si l'accès échoue, désactive les boutons liés à la caméra
                takePhotoBtn.disabled = true;
                flipCameraBtn.disabled = true;
            }
        }

        // Écouteur d'événement pour le bouton "Prendre Photo"
        takePhotoBtn.addEventListener('click', () => {
            if (!stream) {
                alert("La webcam n'est pas démarrée. Veuillez patienter ou recharger la page.");
                return;
            }

            // 1. Nettoie le canvas avant de dessiner
            context.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
            
            // 2. Dessine le cadre sur toute la surface du canvas (il sera la base)
            // Vérifie que l'image du cadre est bien chargée avant de la dessiner
            if (frameOverlay.complete && frameOverlay.naturalWidth > 0) {
                // Dessine le cadre sur toute la surface du canvas
                context.drawImage(frameOverlay, 0, 0, photoCanvas.width, photoCanvas.height);

                // 3. Calcule les dimensions de la zone où la webcam doit être dessinée
                // Ces valeurs sont des estimations basées sur l'image 'Cadre photo png.jpg' (720x960 pixels)
                // et représentent la zone transparente du cadre.
                // Ajuste ces valeurs pour qu'elles correspondent EXACTEMENT à la zone transparente de ton PNG.
                const originalFrameWidth = 720;
                const originalFrameHeight = 960;
                const originalCutoutX = 100; // Position X du début de la zone transparente
                const originalCutoutY = 280; // Position Y du début de la zone transparente
                const originalCutoutWidth = 520; // Largeur de la zone transparente
                const originalCutoutHeight = 400; // Hauteur de la zone transparente

                // Calcule le facteur d'échelle pour adapter les coordonnées originales à la taille actuelle du canvas
                const scaleFactor = photoCanvas.width / originalFrameWidth;

                const targetX = originalCutoutX * scaleFactor;
                const targetY = originalCutoutY * scaleFactor;
                const targetWidth = originalCutoutWidth * scaleFactor;
                const targetHeight = originalCutoutHeight * scaleFactor;

                // 4. Dessine le flux vidéo de la webcam dans la zone calculée, en maintenant son ratio d'aspect
                const videoAspectRatio = webcamFeed.videoWidth / webcamFeed.videoHeight;
                const targetAspectRatio = targetWidth / targetHeight;

                let drawVideoWidth = targetWidth;
                let drawVideoHeight = targetHeight;
                let drawVideoX = targetX;
                let drawVideoY = targetY;

                if (videoAspectRatio > targetAspectRatio) {
                    // La vidéo est plus large que la zone cible, on l'ajuste par la hauteur et on la centre horizontalement
                    drawVideoHeight = targetHeight;
                    drawVideoWidth = targetHeight * videoAspectRatio;
                    drawVideoX = targetX + (targetWidth - drawVideoWidth) / 2;
                } else {
                    // La vidéo est plus haute que la zone cible, on l'ajuste par la largeur et on la centre verticalement
                    drawVideoWidth = targetWidth;
                    drawVideoHeight = targetWidth / videoAspectRatio;
                    drawVideoY = targetY + (targetHeight - drawVideoHeight) / 2;
                }

                // Dessine le flux webcam SANS l'effet miroir pour la photo finale
                // L'effet miroir est géré uniquement par le CSS de #webcam-feed pour la prévisualisation en direct.
                context.drawImage(webcamFeed, drawVideoX, drawVideoY, drawVideoWidth, drawVideoHeight);

            } else {
                console.warn("L'image du cadre n'est pas encore chargée ou est invalide. Assurez-vous que 'Cadre photo png.jpg' est dans le bon dossier.");
                alert("Le cadre n'a pas pu être appliqué. La photo a été prise sans cadre.");
                // Si le cadre ne peut pas être chargé, dessine juste la webcam (non-miroir)
                context.drawImage(webcamFeed, 0, 0, photoCanvas.width, photoCanvas.height);
            }

            // 5. Récupère la photo finale du canvas sous forme d'URL de données (Base64)
            photoDataUrl = photoCanvas.toDataURL('image/png');
            downloadBtn.disabled = false; // Active le bouton de téléchargement
        });

        // Écouteur d'événement pour le bouton "Changer de caméra"
        flipCameraBtn.addEventListener('click', async () => {
            if (videoInputDevices.length <= 1) {
                console.log("Moins de 2 caméras disponibles, impossible de changer.");
                return;
            }

            // Trouver l'index de la caméra actuelle
            const currentIndex = videoInputDevices.findIndex(device => device.deviceId === currentCameraId);
            // Calculer l'index de la prochaine caméra
            const nextIndex = (currentIndex + 1) % videoInputDevices.length;
            const nextCamera = videoInputDevices[nextIndex];

            currentCameraId = nextCamera.deviceId; // Met à jour l'ID de la caméra actuelle
            await startWebcam(currentCameraId); // Démarre la webcam avec la nouvelle caméra
        });


        // Écouteur d'événement pour le bouton "Télécharger"
        downloadBtn.addEventListener('click', () => {
            if (photoDataUrl) {
                // Crée un élément <a> temporaire pour le téléchargement
                const link = document.createElement('a');
                link.href = photoDataUrl; // L'URL de la photo
                link.download = 'Ma_Photo_Souvenir_La_Reunion.png'; // Nom du fichier à télécharger
                document.body.appendChild(link); // Ajoute le lien au corps du document
                link.click(); // Simule un clic sur le lien pour déclencher le téléchargement
                document.body.removeChild(link); // Supprime le lien temporaire
            }
        });

        // Démarrer la webcam et énumérer les caméras au chargement complet de la page
        window.addEventListener('load', async () => {
            await enumerateCameras(); // Énumère les caméras avant de démarrer
            await startWebcam(); // Démarre la webcam (utilisera la première ou la frontale par défaut)
        });

        // Arrêter le flux de la webcam lorsque l'utilisateur quitte ou ferme la page
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop()); // Arrête toutes les pistes du flux
            }
        });

        // Enregistrement du Service Worker (pour la fonctionnalité PWA)
        // Vérifie si le navigateur supporte les Service Workers
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Tente d'enregistrer le Service Worker
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker enregistré avec succès:', registration);
                    })
                    .catch(error => {
                        console.error('Échec de l\'enregistrement du Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
